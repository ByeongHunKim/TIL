# JPA 개발자를 위한 Mysql 쿼리이야기

> 발표자 : 우아한형제들 정산시스템팀 이동욱
>
> 발표 듣기 전에 보면 좋을 것들
>
> - 우아콘
> - 사내 위키
> - 블로그
>
> 주제
>
> - 수백만 ~ 수천만 데이터에도 효과가 있는 성능 튜닝, 디버깅 이야기
>
> 대상
>
> - JPA를 사용하는 2~5년차 애플리케이션 개발자

## 서론

### 왜 이 발표를 들어야 하나?

* 과거
  * 개발자가 SQL 작성
  * DBA가 SQL 검수
  * 쿼리가 Object가 되고, 쿼리가 만능이 된다.
* 현재
  * JPA/Querydsl 작성하고 배포 한다.
  * Slow쿼리나 / 장애 발생한다. 그때 DBA가 알 수 있다.
  * JPA/Querydsl을 사용하면 슬로우/장애의 1차 책임자는 개발자다.

### 수천만 수억건이면 NoSQL쓰면 되지 않나요?

* 수천 ~. 수억건 정도는 Aurora 환경이면 큰 문제 없이 대응가능한 사내 노하우가 쌓여 있다.
* MySQL 처럼 대중화되고, 사내 레퍼런스도 많은 데이터 스토어도 공부 안하는데, 몽고 레디스는 공부할까?
  * 한번쯤은 데이터스토어 중 1개를 제대로 공부해 볼 필요가 있다.

## 본론

### 배경지식

* Join 탐색 방식
* Access
  * Random Access
  * Sequencial Access

### 서브쿼리 - SELECT

* MySQL 5.6에서 서브쿼리 최적화가 되었다.

### 서브쿼리 - UPDATE / DELETE

* MySQL 8.0까지 UPDATE/DELETE는 서브쿼리 최적화가 지원되지 않는다.
* 서브쿼리 대신에 조인으로 바꾸자.

### 서브쿼리

* 굳이 조인 가능한데 이해하기 쉽다고 서브쿼리로 하지말고
* 조인이 가능하면 무조건 조인을 쓴다.
* 조인이 서브쿼리보다 성능상 손해보는 경우가 거의 없다.
* JPA / Querydsl에서는 서브쿼리 쓸 일이 많이 없다.

### 실행계획

* 사용법 : explain

* `explain format = json` 을 사용하면 더 상세한 실행계획을 볼 수 있다.

  * workbench의 visual explain 기능이 이 데이터를 활용한다.

* select_type

  * simple
  * ...

* type

  * range

    * 주어진 범위 내의 row를 스캔한다.
    * <, >, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용한 인덱스 스캔
    * 범위 대상이 넓으면 비효율이 발생한다.

  * const

    * 매칭되는 row가 1건 혹은 / PK 혹은 unique key 사용시

  * eq_ref

    * 1:1 or 1:N 관계에서 N 테이블이 드라이빙 테이블이 되고. 1 테이블의 PK(or Unique Key)를 사용하는 경ㅇ
    * 조인 관계에서는 성능이 좋은 지표

  * ref

    내용추가

  * all

    * 테이블 풀 스캔
    * 전체 데이터 페이지를 모두 읽는 방식으로 성능 개선 필수 대상

  * index

    * 인덱스 풀 스캔
    * 인덱스가 테이블보다 작으므로 ALL 보단 적게 걸린다.

  * index_merge(MySQL 5.6부터 도입)

    * 2개 이상의 인덱스를 이용해 각각의 검색 결과를 병합하는 방식
    * 여러개의 인덱스를 읽어야하므로 일반적으로는 range 보다 성능이 떨어진다

  * 결론

    * 성능이 좋다
      * const, eq_ref
    * 성능 개선 필요
      * all, index
    * 처리 범위에 다르다
      * range, ref, index_merge

* key

  * 옵티마이저가 실제 선택한 인덱스

* extra

  * 쿼리 처리에 사용된 부가정보
  * Using index
    * 커버링 인덱스(인덱스를 탔다의 여부가 아니다.)
  * Using index condition

작성중